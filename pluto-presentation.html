<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pluto Project Presentation</title>
    <link rel="icon" type="image/png" href="favicon.png">

    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">

    <script async src="https://ga.jspm.io/npm:es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js"
        }
    }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background-color: #000000; 
            color: #ffffff; 
            overflow-x: hidden; 
            font-family: 'Inter', sans-serif; 
        }
        #bg {
            position: fixed; 
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh; 
            display: block; 
            z-index: -1; 
        }
        .scroll-spacer {
            height: 2700vh; /* This value largely determines the total scrollable length */
            width: 100%;
        }
        .info-box {
            position: fixed;
            right: 50px; 
            top: -1000px; 
            width: 680px; /* Increased from 400px */
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 25px;
            color: white;
            font-family: 'Inter', sans-serif;
            opacity: 0; 
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            z-index: 100;
        }
        .info-box h2 {
            margin: 0 0 15px 0;
            font-size: 1.5rem;
            font-weight: 500;
            color: #fff;
        }
        .info-box p {
            margin: 0 0 12px 0;
            font-size: 0.95rem;
            line-height: 1.5;
            color: rgba(255, 255, 255, 0.9);
        }
        .info-box img.box-image {
            width: 100%;
            max-width: 420px; 
            height: auto;
            border-radius: 4px;
            margin: 15px auto 10px auto;
            display: block;
        }
        #logoImage {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 700px; 
            max-width: 80%;
            opacity: 0;
            z-index: 150; 
            pointer-events: none; 
        }
        #logoSubtitle {
            position: fixed;
            left: 50%;
            top: 70%; 
            transform: translateX(-50%); 
            width: 90%; 
            max-width: 650px; 
            text-align: center;
            color: #ffffff; 
            font-family: 'Orbitron', sans-serif; 
            font-size: 1.1rem; 
            font-weight: 400;
            line-height: 1.6;
            opacity: 0;
            z-index: 140; 
            pointer-events: none;
        }

        
        #loadingScreenWrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 9999; 
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Arial', sans-serif; 
            opacity: 1;
            visibility: visible;
            color: white; 
        }
        #loadingScreenWrapper.fade-out {
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-out, visibility 0s linear 0.5s;
        }
        #loadingScreenWrapper .loading-container { 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }
        #loadingScreenWrapper .logo-container { 
            width: 200px;
            height: 200px;
            margin-bottom: 30px;
        }
        #loadingScreenWrapper .loading-text { 
            font-size: 18px;
            letter-spacing: 2px;
            margin-top: 20px;
            opacity: 0;
            animation: loadingFadeInOut 2s infinite; 
        }
        #loadingScreenWrapper .brand-name { 
            font-size: 28px;
            font-weight: bold;
            letter-spacing: 4px;
            margin-bottom: 10px;
        }
        #loadingScreenWrapper .tagline { 
            font-size: 14px;
            opacity: 0.7;
            letter-spacing: 1px;
            margin-bottom: 30px;
        }
        @keyframes loadingFadeInOut { 
            0% { opacity: 0.3; }
            50% { opacity: 1; }
            100% { opacity: 0.3; }
        }
        .pluto-styled-button {
            background-color: rgba(0, 0, 0, 0.8);
            color: #ffffff;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            font-weight: 400;
            border: 1px solid rgba(194, 194, 194, 0.5);
            border-radius: 5px;
            padding: 10px 20px;
            cursor: pointer;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .pluto-styled-button:hover {
            background-color: rgba(255, 255, 255, 0.2);
            color: #ffffff;
            border-color: #ffffff;
        }
        .info-box .pluto-styled-button {
            margin-top: 10px; 
            display: inline-block; 
        }
        #logoSubtitle .pluto-styled-button {
            display: block;
            margin: 20px auto 0; 
            pointer-events: auto; 
        }

        #scrollDownIndicator {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-family: 'Orbitron', sans-serif;
            color: white;
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            z-index: 1000;
            opacity: 0; /* Start fully transparent */
            pointer-events: none;
            transition: opacity 0.3s ease-in-out; /* Fade-in transition */
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.9rem;
        }

        #scrollDownIndicator.visible {
            opacity: 1; /* Target opacity for fade-in */
            pointer-events: auto; /* Allow interaction if any, though not typical for an indicator */
        }

        #scrollDownIndicator.pulsing {
            animation: pulseOpacityIndicator 2s infinite ease-in-out;
        }

        @keyframes pulseOpacityIndicator {
            0% { opacity: 1; }   /* Start pulsing from full opacity */
            50% { opacity: 0.6; } /* Dip in opacity */
            100% { opacity: 1; } /* Return to full opacity */
        }
    </style>
</head>
<body>
    <div id="loadingScreenWrapper">
        <div class="loading-container">
            <div class="brand-name">P.L.U.T.O.</div>
            <div class="tagline">Your SMART Personal Assistant.</div>
            
            <div class="logo-container">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
                    
                    <rect width="200" height="200" fill="black"/>
                    
                    <radialGradient id="bg-gradient" cx="100" cy="100" r="100" gradientUnits="userSpaceOnUse">
                        <stop offset="0%" stop-color="#111111"/>
                        <stop offset="100%" stop-color="#000000"/>
                    </radialGradient>
                    <rect width="200" height="200" fill="url(#bg-gradient)"/>
                    
                    
                    <circle cx="100" cy="100" r="60" stroke="white" stroke-width="3" fill="none"/>
                    
                    
                    <g>
                        
                        <animateTransform 
                        attributeName="transform" 
                        attributeType="XML" 
                        type="rotate" 
                        from="0 100 100" 
                        to="-360 100 100" 
                        dur="8s" 
                        repeatCount="indefinite"/>
                        
                        
                        <circle cx="160" cy="100" r="9" fill="white"/>
                        
                        
                        <circle cx="160" cy="100" r="15" stroke="white" stroke-width="0.7" fill="none">
                        
                        <animateTransform 
                            attributeName="transform" 
                            attributeType="XML" 
                            type="rotate" 
                            from="0 160 100" 
                            to="360 160 100" 
                            dur="2s" 
                            repeatCount="indefinite"/>
                        </circle>
                        
                        
                        <circle cx="175" cy="100" r="3" fill="white">
                        
                        <animateTransform 
                            attributeName="transform" 
                            attributeType="XML" 
                            type="rotate" 
                            from="0 160 100" 
                            to="360 160 100" 
                            dur="2s" 
                            repeatCount="indefinite"/>
                        </circle>
                    </g>
                    
                    
                    <circle cx="100" cy="100" r="35" stroke="white" stroke-width="3" fill="none" stroke-dasharray="4 7">
                        <animateTransform 
                        attributeName="transform" 
                        attributeType="XML" 
                        type="rotate" 
                        from="0 100 100" 
                        to="360 100 100" 
                        dur="10s" 
                        repeatCount="indefinite"/>
                    </circle>
                    
                    
                    <circle cx="100" cy="100" r="6" fill="white">
                        <animate 
                        attributeName="r" 
                        values="6;8;6" 
                        dur="3s" 
                        repeatCount="indefinite"
                        calcMode="spline"
                        keySplines="0.42 0 0.58 1; 0.42 0 0.58 1"
                        keyTimes="0; 0.5; 1"/>
                    </circle>
                    
                    
                    <circle cx="100" cy="100" r="8" fill="none" stroke="white" stroke-width="0.5">
                        <animate 
                        attributeName="r" 
                        values="7;12;7" 
                        dur="3.1s" 
                        repeatCount="indefinite"
                        calcMode="spline"
                        keySplines="0.42 0 0.58 1; 0.42 0 0.58 1"
                        keyTimes="0; 0.5; 1"/>
                    </circle>
                    
                    
                    <circle cx="135" cy="102" r="5" fill="white">
                        <animateTransform 
                        attributeName="transform" 
                        attributeType="XML" 
                        type="rotate" 
                        from="0 100 100" 
                        to="360 100 100" 
                        dur="5s" 
                        repeatCount="indefinite"/>
                    </circle>
                </svg>
            </div>
            
            <div class="loading-text">Loading...</div>
        </div>
    </div>

    <canvas id="bg"></canvas>
    
    
    <div class="info-box" id="infoBox1">
        <h2>P.L.U.T.O. Your SMART Personal Assistant</h2>
        <img src="logo-anim.svg" alt="Pluto Logo Animation" class="box-image">
        <p>P.L.U.T.O., an acronym for <b>P</b>roductivity & <b>L</b>ogical <b>U</b>tility <b>T</b>ask <b>O</b>rganizer, is an innovative and forward-thinking personal assistant engineered to transform how individuals manage their daily tasks and optimize their productivity. Unlike traditional assistants that rely on rigid, pre-programmed functionalities, P.L.U.T.O. leverages advanced artificial intelligence and self-learning capabilities to deliver a highly personalized and adaptive user experience.</p>
        <p>This project redefines the concept of a personal assistant by integrating cutting-edge technologies, such as real-time APIs and modular design, with an intuitive interface that evolves to meet the unique and ever-changing needs of each user. By combining intelligence, flexibility, and user-centric design, P.L.U.T.O. aims to become an indispensable tool for professionals, students, and anyone seeking to streamline their workflow and enhance their efficiency in both personal and professional contexts.</p>
    </div>
    <div class="info-box" id="infoBox2">
        <h2>/Inspiration</h2>
        <p>The inspiration for P.L.U.T.O. stemmed the limitations of existing personal assistant technologies, which often provide static, one-size-fits-all solutions that fail to adapt to individual user preferences or evolving needs. While most assistants excel at basic tasks like setting reminders, answering simple queries, or managing calendars, they lack the ability to learn from user interactions or proactively tailor their functionalities. P.L.U.T.O. was envisioned as a dynamic, intelligent companion that grows alongside its user, continuously refining its understanding of their habits, preferences, and goals.</p>
        <p>Drawing inspiration from the concept of a lifelong supporter, the project aims to bridge the gap between advanced technology and practical, everyday utility, creating a seamless integration of AI-driven insights and user-friendly design. The ultimate goal is to empower users with a tool that not only responds to their commands but anticipates their needs, fostering a deeper connection between human and machine to drive unparalleled productivity.</p>
    </div>
    <div class="info-box" id="infoBox3">
        <h2>/What It Does</h2>
        <p>P.L.U.T.O. is a multifaceted personal assistant designed to simplify and amplify productivity through a combination of intelligent communication, adaptive learning, and customizable tools. At its core, it utilizes a real-time OpenAI API to facilitate natural, context-aware conversations, enabling users to interact with the assistant as they would with a knowledgeable colleague or friend. Additionally, P.L.U.T.O. incorporates the o4-mini API, which enhances its ability to learn from user interactions, integrate new functionalities, and refine its performance over time.</p>
        <p>This dual-API approach allows P.L.U.T.O. to perform a wide range of tasks, from managing schedules and answering complex queries to providing tailored recommendations and automating repetitive processes. By adapting to the user’s unique workflow and preferences, P.L.U.T.O. delivers highly personalized solutions that evolve in real time, making it a versatile and indispensable tool for individuals across various domains, whether they’re organizing their workday, pursuing creative projects, or managing personal responsibilities.</p>
    </div>
    <div class="info-box" id="infoBox4">
        <h2>/How I Built It</h2>
        <p>The development of P.L.U.T.O. was a complex yet rewarding process that combined advanced programming techniques, collaborative tools, and innovative AI frameworks. The project was built primarily using Python, leveraging powerful libraries such as OpenAI for natural language processing and dynamic tool memory for structuring adaptive, context-aware interactions. These libraries form the backbone of P.L.U.T.O.’s communication and self-learning capabilities, enabling it to process user inputs and generate intelligent responses.</p>
        <p>To streamline development, we utilized modern coding environments like Visual Studio Code (VSCode), GitHub Copilot, and Cursor IDEs, which facilitated rapid prototyping, debugging, and collaboration among team members. The platform was designed with a modular architecture, ensuring that new features and updates can be seamlessly integrated without disrupting existing functionalities.</p>
    </div>
    <div class="info-box" id="infoBox5">
        <h2>/Challenges Along The Way</h2>
        <p>The journey to bring P.L.U.T.O. to life was not without its hurdles, as the team encountered several technical and conceptual challenges. One of the most significant obstacles was working with the beta version of OpenAI’s real-time API, which, while powerful, suffered from incomplete or ambiguous documentation. This required extensive experimentation, troubleshooting, and iterative testing to fully understand and harness its capabilities. Another challenge was ensuring consistent accuracy in function execution, as the assistant occasionally struggled to interpret complex or ambiguous user requests correctly.</p>
        <p>Achieving this level of precision demanded rigorous fine-tuning of the underlying models, as well as the development of robust error-handling mechanisms to maintain a smooth user experience. Additionally, balancing the assistant’s adaptability with computational efficiency posed a challenge, as the team worked to create a system that could learn and evolve without requiring excessive processing power or latency. Despite these difficulties, each challenge provided valuable insights that strengthened the project’s foundation.</p>
    </div>
    <div class="info-box" id="infoBox6">
        <h2>/Accomplishments</h2>
        <p>The P.L.U.T.O. project has achieved several milestones that reflect the team’s dedication, creativity, and technical expertise. One of the standout accomplishments is the development of an evolving user interface that prioritizes simplicity, intuitiveness, and accessibility, aligning closely with the project’s vision of creating a user-friendly assistant for all. This interface adapts to user preferences, offering a personalized experience that feels natural and engaging.</p>
        <p>Another significant achievement is the successful integration of OpenAI’s ethical database, which ensures that P.L.U.T.O. operates with transparency, fairness, and respect for user values, addressing growing concerns about AI ethics and responsibility.</p>
        <p>Additionally, I am proud of overcoming the technical challenges associated with the real-time API, resulting in a robust and reliable system that delivers consistent performance. These accomplishments not only validate the project’s ambitious goals but also set a strong foundation for future enhancements and widespread adoption.</p>
    </div>
    <div class="info-box" id="infoBox7">
        <h2>/Things I Learned</h2>
        <p>The development of P.L.U.T.O. has been a profound learning experience, yielding valuable insights into AI development, user experience design, and project management. One of the key lessons was mastering the implementation of OpenAI’s real-time API, which required a deep understanding of its capabilities and limitations to achieve optimal performance. The team also learned how to curate adaptive agent responses that align closely with user intent, using techniques like context retention and personalized memory storage to enhance the assistant’s relevance and effectiveness.</p>
        <p>Furthermore, leveraging stored memory to create a tailored user experience taught us the importance of balancing data privacy with personalization, ensuring that user information is handled securely and ethically. Beyond technical skills, the project underscored the value of collaboration, perseverance, and iterative problem-solving, as the team navigated complex challenges to bring their vision to life. These lessons will continue to guide the project’s evolution and inform future innovations.</p>
        <p>Ethical considerations were paramount throughout P.L.U.T.O.'s development. We learned the critical importance of designing AI systems that are not only intelligent but also fair, transparent, and accountable. This involved exploring methods to mitigate biases in training data, ensuring user privacy by implementing robust data handling practices, and providing clarity on how AI-driven decisions are made. The integration of OpenAI's ethical guidelines served as a foundational framework, guiding us in creating an assistant that respects user values and promotes responsible AI use. This hands-on experience reinforced the necessity of a proactive approach to AI ethics, embedding these principles into the core design rather than treating them as an afterthought.</p>
    </div>
    <div class="info-box" id="infoBox8">
        <h2>/What's Next?</h2>
        <p>The future of P.L.U.T.O. is brimming with exciting possibilities as we work to refine and expand its capabilities to meet the needs of a growing user base. A top priority is enhancing the user interface, focusing on both usability and aesthetics to create a visually appealing and effortless experience across all devices. We also plan to introduce a Public Tool Creator, an innovative feature that will allow users to design and contribute their own tools and functionalities, fostering a collaborative ecosystem where the community can shape P.L.U.T.O.’s evolution.</p>
        <p>Additionally, a dedicated website and web application are in development, providing users with a centralized platform to access P.L.U.T.O., explore its features, and connect with other users. To further improve performance, we are committed to fine-tuning the assistant’s learning algorithms and real-time models, optimizing function calling and adaptability to ensure faster, more accurate responses. Ultimately, our goal is to position P.L.U.T.O. as a leading personal assistant that empowers users worldwide to achieve their goals with greater ease and efficiency.</p>
    </div>
    <div class="info-box" id="infoBox9">
        <h2>/Try It Yourself!</h2>
        <p>Ready to experience the power of P.L.U.T.O. for yourself? Give the private demo a try!</p>
        <p>(Contact me through Discord (@Alt-F17) to get the password to access the closed Beta)</p>
        <img src="Instructions.png" alt="Pluto AI Instructions Snippet" class="box-image">
        <button id="demoButton" class="pluto-styled-button">P.L.U.T.O. Demo - WIP</button>
    </div>

    <div class="scroll-spacer"></div>

    
    <img id="logoImage" src="logo-anim.svg" alt="Pluto Logo Animation">
    
    <div id="logoSubtitle">
        YOUR SMART, INTUITIVE, SELF TAUGHT PERSONAL ASSISTANT
        <button id="subtitleDemoButton" class="pluto-styled-button">demo - Coming Soon</button>
    </div>

    <div id="scrollDownIndicator">Scroll Down</div>

    <script type="module">
        import * as THREE from 'three';

        function isWebGLAvailable() {
            try {
                const canvas = document.createElement('canvas');
                return !!(window.WebGLRenderingContext && 
                    (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
            } catch (e) {
                return false;
            }
        }

        if (!isWebGLAvailable()) {
            const warning = document.createElement('div');
            warning.style.position = 'absolute';
            warning.style.top = '50%';
            warning.style.left = '50%';
            warning.style.transform = 'translate(-50%, -50%)';
            warning.style.color = 'white';
            warning.style.padding = '20px';
            warning.style.background = 'rgba(0,0,0,0.8)';
            warning.style.borderRadius = '5px';
            warning.innerHTML = 'Your browser does not support WebGL, which is required for this animation.';
            document.body.appendChild(warning);
        }

        const PLANET_COUNT = 5;
        const SUN_SIZE = 15;
        const MAX_ORBIT_RADIUS = 150;
        const MIN_ORBIT_RADIUS = 40;
        const MAX_PLANET_SIZE = 5;
        const MIN_PLANET_SIZE = 2;
        const MAX_PLANET_SPEED = 0.005;
        const MIN_PLANET_SPEED = 0.001;
        const LOW_POLY_DETAIL = 9;
        const PLANET_ROTATION_SPEED_X = 0.003;
        const PLANET_ROTATION_SPEED_Y = 0.005;
        const PLANET_ROTATION_SPEED_Z = 0.001;
        const STARFIELD_COUNT = 800;
        const CAMERA_INITIAL_Z = 300;
        const CAMERA_ZOOM_DISTANCE = 28;
        const CAMERA_ZOOM_OFFSET_Y = 5;
        const CAMERA_ZOOM_OFFSET_X = -15;
        const ORBIT_TILT_AMOUNT = Math.PI / 2 * 0.85;
        const SCROLL_TRIGGER_START_VH = 0.2;
        const SCROLL_TRANSITION_DURATION_VH = 2.0;
        const SCENE_PAN_LEFT_AMOUNT = 16;
        const NUM_INFO_BOXES = 9;
        const INFO_BOX_FADE_DURATION_VH = 0.5;
        const INFO_BOX_DISPLAY_DURATION_VH = 1.0;
        const INFO_BOX_SPACING_VH = 0.2;
        const INFO_BOX_VISIBLE_TOP_PX = 50;
        const PRE_INFO_BOX_SCROLL_GAP_VH = 1.0;
        const IMAGE_FADE_START_OFFSET_VH = 1.5; 
        const IMAGE_FADE_DURATION_VH = 1.0; 
        const CAMERA_SHIFT_UP_AMOUNT = 150;
        const Easing = {
            easeInOutCubic: function(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            },
            easeInOutQuint: function(t) {
                return t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2;
            },
            smoothstep: function(t) {
                return t * t * (3 - 2 * t);
            }
        };

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({
            canvas: document.querySelector('#bg'),
            antialias: true,
            alpha: true,
            powerPreference: 'high-performance',
            precision: 'highp',
            stencil: false,
            depth: true,
            logarithmicDepthBuffer: true
        });

        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.physicallyCorrectLights = true;

        camera.position.set(0, 0, CAMERA_INITIAL_Z);
        const initialCameraPos = camera.position.clone();

        function createStarfield() {
            const stars = new THREE.Group();
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 1,
                sizeAttenuation: false
            });

            const starVertices = [];
            for (let i = 0; i < STARFIELD_COUNT; i++) {
                const radius = 400 + Math.random() * 200;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);

                starVertices.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const starField = new THREE.Points(starGeometry, starMaterial);
            stars.add(starField);
            return stars;
        }
        const starfield = createStarfield();
        scene.add(starfield);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0);
        directionalLight.position.set(50, 50, 100);
        scene.add(directionalLight);

        const orbitGroup = new THREE.Group();
        scene.add(orbitGroup);

        const basicWhiteMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffffff,
            transparent: true,
            opacity: 1.0
        });
        
        const standardWhiteMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.8,
            metalness: 0.1,
            wireframe: false,
            transparent: true,
            opacity: 1.0
        });
        const orbitLineMaterial = new THREE.LineBasicMaterial({
            color: 0xaaaaaa,
            transparent: true,
            opacity: 0.4
        });

        const sunGeometry = new THREE.SphereGeometry(SUN_SIZE, 32, 16);
        const sunMesh = new THREE.Mesh(sunGeometry, basicWhiteMaterial);
        let sunIs3D = false;
        orbitGroup.add(sunMesh);
        const planets = [];
        let outermostPlanetData = null;
        let maxRadiusFound = 0;

        for (let i = 0; i < PLANET_COUNT; i++) {
            const orbitRadius = MIN_ORBIT_RADIUS + (i / Math.max(1, PLANET_COUNT - 1)) * (MAX_ORBIT_RADIUS - MIN_ORBIT_RADIUS);
            const planetSize = MIN_PLANET_SIZE + Math.random() * (MAX_PLANET_SIZE - MIN_PLANET_SIZE);
            const initialAngle = Math.random() * Math.PI * 2;
            const speed = MIN_PLANET_SPEED + Math.random() * (MAX_PLANET_SPEED - MIN_PLANET_SPEED);
            const planetGeo2D = new THREE.CircleGeometry(planetSize, 32);
            const planetGeo3D = new THREE.IcosahedronGeometry(planetSize, LOW_POLY_DETAIL);
            planetGeo3D.computeVertexNormals();
            const planetMesh2D = new THREE.Mesh(planetGeo2D, basicWhiteMaterial.clone());
            const planetMesh3D = new THREE.Mesh(planetGeo3D, standardWhiteMaterial.clone());
            planetMesh2D.position.x = orbitRadius * Math.cos(initialAngle);
            planetMesh2D.position.y = orbitRadius * Math.sin(initialAngle);
            planetMesh2D.position.z = 0;
            planetMesh2D.visible = true;
            planetMesh3D.position.x = orbitRadius * Math.cos(initialAngle);
            planetMesh3D.position.y = orbitRadius * Math.sin(initialAngle);
            planetMesh3D.position.z = 0;
            planetMesh3D.visible = false;
            planetMesh3D.scale.set(0.01, 0.01, 0.01);
            orbitGroup.add(planetMesh2D);
            orbitGroup.add(planetMesh3D);
            const orbitPoints = [];
            const orbitSegments = 512; // Increased from 64
            for (let j = 0; j <= orbitSegments; j++) {
                const theta = (j / orbitSegments) * Math.PI * 2;
                orbitPoints.push(new THREE.Vector3(orbitRadius * Math.cos(theta), orbitRadius * Math.sin(theta), 0));
            }
            const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
            const orbitLine = new THREE.LineLoop(orbitGeometry, orbitLineMaterial.clone());
            orbitGroup.add(orbitLine);

            const planetData = {
                mesh2D: planetMesh2D,
                mesh3D: planetMesh3D,
                currentMesh: planetMesh2D,
                orbitLine: orbitLine,
                orbitRadius: orbitRadius,
                angle: initialAngle,
                speed: speed,
                planetSize: planetSize,
                transitionState: 0,
                transitionProgress: 0
            };
            planets.push(planetData);

            if (orbitRadius > maxRadiusFound) {
                maxRadiusFound = orbitRadius;
                outermostPlanetData = planetData;
            }
        }

        const infoBoxElements = [];
        for (let i = 1; i <= NUM_INFO_BOXES; i++) {
            infoBoxElements.push(document.getElementById(`infoBox${i}`));
        }

        let currentScrollY = window.scrollY;
        let scrollTriggerStartPixels = window.innerHeight * SCROLL_TRIGGER_START_VH;
        let zoomTransitionEndPixels = scrollTriggerStartPixels + window.innerHeight * SCROLL_TRANSITION_DURATION_VH;
        let infoBoxSequenceStartPixels;
        let infoBoxSequenceEndPixels;
        let imageFadeStartPixels;
        let imageFadeEndPixels;

        function updateScrollThresholds() {
            scrollTriggerStartPixels = window.innerHeight * SCROLL_TRIGGER_START_VH;
            zoomTransitionEndPixels = scrollTriggerStartPixels + window.innerHeight * SCROLL_TRANSITION_DURATION_VH;
            infoBoxSequenceStartPixels = zoomTransitionEndPixels + window.innerHeight * PRE_INFO_BOX_SCROLL_GAP_VH;
            const singleBoxFullCycleDurationVH = INFO_BOX_FADE_DURATION_VH + INFO_BOX_DISPLAY_DURATION_VH + INFO_BOX_FADE_DURATION_VH;
            const scrollPerBoxCycleAndSpacingVH = singleBoxFullCycleDurationVH + INFO_BOX_SPACING_VH;
            const lastBoxStartIndex = NUM_INFO_BOXES - 1;
            const lastBoxStartOffsetVH = lastBoxStartIndex * scrollPerBoxCycleAndSpacingVH;
            infoBoxSequenceEndPixels = infoBoxSequenceStartPixels + window.innerHeight * (lastBoxStartOffsetVH + singleBoxFullCycleDurationVH);
            imageFadeStartPixels = infoBoxSequenceEndPixels + window.innerHeight * IMAGE_FADE_START_OFFSET_VH;
            imageFadeEndPixels = imageFadeStartPixels + window.innerHeight * IMAGE_FADE_DURATION_VH; // This is the calculated pixel value where the last animation ends
        }
        updateScrollThresholds();


        function handleScroll() {
            currentScrollY = window.scrollY;
        }
        window.addEventListener('scroll', handleScroll, { passive: true });
        const clock = new THREE.Clock();
        let lastScrollProgress = 0;
        let currentOrbitGroupX = 0;
        let currentStarfieldX = 0;
        let lastImagePhaseProgress = 0;
        const logoImageElement = document.getElementById('logoImage');
        const logoSubtitleElement = document.getElementById('logoSubtitle');
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            const zoomTransitionPixelLength = zoomTransitionEndPixels - scrollTriggerStartPixels;
            
            let rawScrollProgress = 0;
            if (currentScrollY > scrollTriggerStartPixels && zoomTransitionPixelLength > 0) {
                rawScrollProgress = Math.max(0, Math.min(1,
                    (currentScrollY - scrollTriggerStartPixels) / zoomTransitionPixelLength
                ));
            } else if (currentScrollY <= scrollTriggerStartPixels) {
                rawScrollProgress = 0;
            } else {
                rawScrollProgress = 1;
            }
            const scrollDamping = 0.1;
            const panDamping = 0.08;
            const scrollProgress = lastScrollProgress + (rawScrollProgress - lastScrollProgress) * scrollDamping;
            lastScrollProgress = scrollProgress;
            const easedScrollProgress = Easing.easeInOutCubic(scrollProgress);
            const morphValue = Easing.smoothstep(scrollProgress);
            planets.forEach(planet => {
                planet.angle += planet.speed;
                const newX = planet.orbitRadius * Math.cos(planet.angle);
                const newY = planet.orbitRadius * Math.sin(planet.angle);
                planet.mesh2D.position.x = newX;
                planet.mesh2D.position.y = newY;
                planet.mesh3D.position.x = newX;
                planet.mesh3D.position.y = newY;
                planet.mesh2D.visible = true;
                if (morphValue > 0) {
                    if (!planet.mesh3D.visible) {
                        planet.mesh3D.visible = true;
                        planet.mesh3D.scale.set(0.01, 0.01, 0.01);
                    }
                    
                    const scaleValue = Easing.easeInOutCubic(morphValue);
                    planet.mesh3D.scale.set(scaleValue, scaleValue, scaleValue);
                    
                    planet.mesh3D.material.opacity = morphValue;
                    planet.mesh2D.material.opacity = 1 - morphValue;
                    
                    planet.mesh3D.rotation.x += PLANET_ROTATION_SPEED_X * deltaTime * 60;
                    planet.mesh3D.rotation.y += PLANET_ROTATION_SPEED_Y * deltaTime * 60;
                } else {
                    if (planet.mesh3D.visible) {
                        planet.mesh3D.visible = false;
                    }
                    planet.mesh2D.material.opacity = 1.0;
                }
                
                if (planet.mesh2D.material.opacity < 0.01) {
                    planet.mesh2D.visible = false;
                }
            });

            const isDuringTextBoxesPhase = currentScrollY >= infoBoxSequenceStartPixels && currentScrollY < infoBoxSequenceEndPixels;

            infoBoxElements.forEach((box, index) => {
                if (!box) return;
                const singleBoxFullCycleDurationVH = INFO_BOX_FADE_DURATION_VH + INFO_BOX_DISPLAY_DURATION_VH + INFO_BOX_FADE_DURATION_VH;
                const scrollPerBoxCycleAndSpacingVH = singleBoxFullCycleDurationVH + INFO_BOX_SPACING_VH;
                const boxStartScrollY = infoBoxSequenceStartPixels + index * window.innerHeight * scrollPerBoxCycleAndSpacingVH;
                const fadeInEndScrollY = boxStartScrollY + window.innerHeight * INFO_BOX_FADE_DURATION_VH;
                const displayEndScrollY = fadeInEndScrollY + window.innerHeight * INFO_BOX_DISPLAY_DURATION_VH;
                const fadeOutEndScrollY = displayEndScrollY + window.innerHeight * INFO_BOX_FADE_DURATION_VH;
                let currentBoxOpacity = 0;
                const boxHeight = box.offsetHeight; 

                if (currentScrollY >= boxStartScrollY && currentScrollY < fadeInEndScrollY) {
                    const progress = (currentScrollY - boxStartScrollY) / (fadeInEndScrollY - boxStartScrollY);
                    currentBoxOpacity = progress;
                    const startTop = -boxHeight;
                    box.style.top = `${startTop + (INFO_BOX_VISIBLE_TOP_PX - startTop) * Easing.easeInOutQuint(progress)}px`;
                } else if (currentScrollY >= fadeInEndScrollY && currentScrollY < displayEndScrollY) {
                    currentBoxOpacity = 1;
                    box.style.top = `${INFO_BOX_VISIBLE_TOP_PX}px`;
                } else if (currentScrollY >= displayEndScrollY && currentScrollY < fadeOutEndScrollY) {
                    const progress = (currentScrollY - displayEndScrollY) / (fadeOutEndScrollY - displayEndScrollY);
                    currentBoxOpacity = 1 - progress;
                    const endTop = window.innerHeight;
                    box.style.top = `${INFO_BOX_VISIBLE_TOP_PX + (endTop - INFO_BOX_VISIBLE_TOP_PX) * Easing.easeInOutQuint(progress)}px`;
                } else {
                    currentBoxOpacity = 0;
                    if (currentScrollY < boxStartScrollY || currentScrollY >= fadeOutEndScrollY) {
                         box.style.top = `${-boxHeight - 50}px`;
                    }
                }
                
                box.style.opacity = Easing.easeInOutQuint(currentBoxOpacity);
            });
            
            const targetScenePanX = isDuringTextBoxesPhase ? -SCENE_PAN_LEFT_AMOUNT : 0;

            currentOrbitGroupX += (targetScenePanX - currentOrbitGroupX) * panDamping;
            currentStarfieldX += (targetScenePanX * 0.25 - currentStarfieldX) * panDamping; 

            if (morphValue > 0) {
                if (!sunMesh.userData.meshStandard) {
                    const standardSun = new THREE.Mesh(sunGeometry, standardWhiteMaterial.clone());
                    standardSun.visible = true;
                    standardSun.scale.set(0.01, 0.01, 0.01);
                    orbitGroup.add(standardSun);
                    sunMesh.userData.meshStandard = standardSun;
                }
                
                sunMesh.visible = true;
                sunMesh.userData.meshStandard.visible = true;
                
                const sunScale = Easing.easeInOutCubic(morphValue);
                sunMesh.userData.meshStandard.scale.set(sunScale, sunScale, sunScale);
                
                sunMesh.userData.meshStandard.material.opacity = morphValue;
                sunMesh.material.opacity = 1 - morphValue;
                
                if (morphValue > 0.999) {
                    sunIs3D = true;
                }
                
                if (sunMesh.material.opacity < 0.01) {
                    sunMesh.visible = false;
                }
            } else if (morphValue === 0 && sunIs3D) {
                sunMesh.material = basicWhiteMaterial;
                sunMesh.material.opacity = 1;
                sunMesh.visible = true;
                
                if (sunMesh.userData.meshStandard) {
                    sunMesh.userData.meshStandard.visible = false;
                    orbitGroup.remove(sunMesh.userData.meshStandard);
                    sunMesh.userData.meshStandard = null;
                }
                
                sunIs3D = false;
            }

            if (outermostPlanetData) {
                const targetPlanet = outermostPlanetData;
                const targetMesh = morphValue > 0.5 ? targetPlanet.mesh3D : targetPlanet.mesh2D;

                const actualPannedPlanetWorldPos = new THREE.Vector3();
                targetMesh.getWorldPosition(actualPannedPlanetWorldPos);
                
                const stableReferencePlanetWorldPos = actualPannedPlanetWorldPos.clone();
                stableReferencePlanetWorldPos.x -= currentOrbitGroupX; 

                const baseCameraPos = new THREE.Vector3(
                    stableReferencePlanetWorldPos.x + CAMERA_ZOOM_OFFSET_X,
                    stableReferencePlanetWorldPos.y + CAMERA_ZOOM_OFFSET_Y,
                    stableReferencePlanetWorldPos.z + CAMERA_ZOOM_DISTANCE
                );
                
                camera.position.lerpVectors(
                    initialCameraPos, 
                    baseCameraPos, 
                    Easing.easeInOutCubic(scrollProgress)
                );

                const currentPlanetAngle = Math.atan2(targetMesh.position.y, targetMesh.position.x);
                const desiredFinalAngle = Math.PI;
                let angleDifference = desiredFinalAngle - currentPlanetAngle;
                while (angleDifference < -Math.PI) angleDifference += Math.PI * 2;
                while (angleDifference > Math.PI) angleDifference -= Math.PI * 2;
                const finalTargetRotationZ = angleDifference;

                orbitGroup.rotation.z = THREE.MathUtils.lerp(
                    0, 
                    finalTargetRotationZ, 
                    Easing.easeInOutCubic(scrollProgress)
                );
                orbitGroup.rotation.x = THREE.MathUtils.lerp(
                    0, 
                    ORBIT_TILT_AMOUNT, 
                    Easing.easeInOutCubic(scrollProgress)
                );

                const initialLookAt = new THREE.Vector3(0, 0, 0);
                const finalLookAt = stableReferencePlanetWorldPos; 
                const currentLookAt = new THREE.Vector3().lerpVectors(
                    initialLookAt, 
                    finalLookAt, 
                    Easing.easeInOutCubic(scrollProgress)
                );
                camera.lookAt(currentLookAt);

                let rawImagePhaseProgress = 0;
                const imageFadeDurationPixels = imageFadeEndPixels - imageFadeStartPixels;

                if (currentScrollY > imageFadeStartPixels && imageFadeDurationPixels > 0) {
                    rawImagePhaseProgress = Math.max(0, Math.min(1,
                        (currentScrollY - imageFadeStartPixels) / imageFadeDurationPixels
                    ));
                } else if (currentScrollY <= imageFadeStartPixels) {
                    rawImagePhaseProgress = 0;
                } else { 
                    rawImagePhaseProgress = 1;
                }

                const imagePhaseDamping = 0.07;
                const imagePhaseProgress = lastImagePhaseProgress + (rawImagePhaseProgress - lastImagePhaseProgress) * imagePhaseDamping;
                lastImagePhaseProgress = imagePhaseProgress;
                const easedImagePhaseProgress = Easing.easeInOutCubic(imagePhaseProgress);

                if (logoImageElement) {
                    logoImageElement.style.opacity = easedImagePhaseProgress;
                }
                if (logoSubtitleElement) {
                    logoSubtitleElement.style.opacity = easedImagePhaseProgress;
                }

                camera.position.y += easedImagePhaseProgress * CAMERA_SHIFT_UP_AMOUNT;

                ambientLight.intensity = THREE.MathUtils.lerp(
                    0.1, 
                    0.6, 
                    Easing.smoothstep(scrollProgress)
                );
                directionalLight.intensity = THREE.MathUtils.lerp(
                    0, 
                    1.0, 
                    Easing.smoothstep(scrollProgress)
                );

                const fadeProgress = Easing.smoothstep(Math.min(1, scrollProgress * 1.5));
                planets.forEach(p => {
                    if (p !== targetPlanet) {
                        p.mesh2D.material.opacity = Math.max(0, 1 - fadeProgress);
                        if (p.mesh3D.visible) {
                            p.mesh3D.material.opacity = Math.max(0, 1 - fadeProgress);
                        }
                    }
                    
                    if (p.orbitLine && p.orbitLine.material) {
                        p.orbitLine.material.opacity = Math.max(0, 0.5 - fadeProgress * 0.5);
                    }
                });
            }
            starfield.rotation.y += deltaTime * 0.01;
            starfield.rotation.x += deltaTime * 0.005;
            renderer.render(scene, camera);
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            updateScrollThresholds();
        }
        window.addEventListener('resize', onWindowResize);
        animate();
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const loadingScreen = document.getElementById('loadingScreenWrapper');
            if (loadingScreen) {
                document.body.style.overflow = 'hidden';
                setTimeout(() => {
                    loadingScreen.classList.add('fade-out');
                    
                    loadingScreen.addEventListener('transitionend', () => {
                        loadingScreen.style.display = 'none';
                        document.body.style.overflowX = 'hidden';
                        document.body.style.overflowY = 'auto';
                    }, { once: true });

                }, 2500);
            } else {
                document.body.style.overflowX = 'hidden';
                document.body.style.overflowY = 'auto';
            }

            const demoButton = document.getElementById('demoButton');
            if (demoButton) {
                demoButton.addEventListener('click', () => {
                    window.open('https://pluto-assistant.com', '_blank');
                });
            }
            const subtitleDemoButton = document.getElementById('subtitleDemoButton');
            if (subtitleDemoButton) {
                subtitleDemoButton.addEventListener('click', () => {
                    window.open('https://pluto-assistant.com', '_blank');
                });
            }

            const scrollIndicator = document.getElementById('scrollDownIndicator');
            let idleTimer = null;
            let pulseTimer = null; // Timer for adding pulsing class
            const IDLE_TIMEOUT_DURATION = 5000; // 5 seconds
            const FADE_IN_DURATION = 300; // 0.3 seconds, matches CSS opacity transition

            function showIndicator() {
                // Show only if at the top, indicator exists, and it's not already visible
                if (window.scrollY === 0 && scrollIndicator && !scrollIndicator.classList.contains('visible')) {
                    scrollIndicator.classList.add('visible'); // Start fade-in by triggering opacity transition
                    
                    clearTimeout(pulseTimer); // Clear previous pulse timer if any
                    pulseTimer = setTimeout(() => {
                        // Add pulsing class only if the indicator is still meant to be visible
                        if (scrollIndicator.classList.contains('visible')) { 
                           scrollIndicator.classList.add('pulsing'); // Start pulsing animation
                        }
                    }, FADE_IN_DURATION);
                }
            }

            function hideIndicator() {
                if (scrollIndicator) {
                    scrollIndicator.classList.remove('visible');
                    scrollIndicator.classList.remove('pulsing');
                    clearTimeout(pulseTimer); // Clear the timer for adding pulsing class
                }
            }

            function updateScrollIndicatorVisibility() {
                clearTimeout(idleTimer); // Clear the main idle timer

                if (window.scrollY === 0) {
                    // User is at the top. Set a new idle timer to show the indicator.
                    idleTimer = setTimeout(showIndicator, IDLE_TIMEOUT_DURATION);
                } else {
                    // User has scrolled away from the top. Hide indicator immediately.
                    hideIndicator();
                }
            }

            window.addEventListener('scroll', () => {
                // When user scrolls, always hide the indicator first.
                // Then, updateScrollIndicatorVisibility will decide if a new idle timer should start.
                hideIndicator(); 
                updateScrollIndicatorVisibility();
            }, { passive: true });

            // Initial check when the page loads
            updateScrollIndicatorVisibility();
        });
    </script>
</body>
</html>
